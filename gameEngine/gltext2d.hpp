/* ***********************************************************************************
 * Copyright (C) 2015-2018 Xavier Direz - http://www.LaFaceObscureDuPixel.fr         *
 *                                                                                   *
 * This file is part of ObscureGameEngine.                                           *
 *                                                                                   *
 * ObscureGameEngine is free software; you can redistribute it and/or modify         *
 * it under the terms of the GNU Lesser General Public License as published by       *
 * the Free Software Foundation; either version 3 of the License, or                 *
 * (at your option) any later version.                                               *
 *                                                                                   *
 * ObscureGameEngine is distributed in the hope that it will be useful,              *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of                    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                     *
 * GNU Lesser General Public License for more details.                               *
 *                                                                                   *
 * You should have received a copy of the GNU Lesser General Public License          *
 * along with  this program; If not, see <http://www.gnu.org/licenses/>.             *
 *************************************************************************************/

#ifndef __GL_TEXT_2D_HPP__
#define __GL_TEXT_2D_HPP__
#include "SDL2/SDL.h"
#include <GL/glew.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "vector"
#include <string.h>

using namespace std;

/// Définition de la police de caractères
//GLubyte rasters[][13] = {

/**
	Classe permettant l'affichage de texte dans un canvas OpenGL
*/
class glText2d
{
	protected:

	GLubyte rasters[95][13];
 	GLuint fontOffset;	/**< Offset de la police de caractères
  							généré à la construction par la fonction glGenLists(128);
 							puis utilisé par PrintString(char *s);*/
 	int x_resolution;	//!< Résolution X de l'écran
 	int y_resolution;	//!< Résolution Y de l'écran

	public:
 	int char_width;
 	int char_height;


	/**
		Construction d'une occurence de glText2d. Pour le moment, tout ceci
		manque de souplesse. Ce sera amélioré ultérieurement. L'objectif était
		juste ici d'avoir un affichage de texte assez rapidement de manière à
		ne plus dépendre de la fenêtre de texte.
	*/
 	glText2d(int x_resolution=1024, int y_resolution=768)
	{
		GLubyte tmp_rasters[95][13]={
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36},
		{0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x66, 0x00, 0x00},
		{0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18},
		{0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70},
		{0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e},
		{0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c},
		{0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30},
		{0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00},
		{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03},
		{0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c},
		{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18},
		{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e},
		{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e},
		{0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c},
		{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
		{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
		{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff},
		{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
		{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
		{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06},
		{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60},
		{0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e},
		{0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18},
		{0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
		{0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
		{0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc},
		{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
		{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff},
		{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
		{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
		{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e},
		{0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06},
		{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3},
		{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
		{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3},
		{0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3},
		{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e},
		{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
		{0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c},
		{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
		{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e},
		{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff},
		{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
		{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
		{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
		{0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
		{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
		{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff},
		{0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c},
		{0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60},
		{0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18},
		{0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70},
		{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
		{0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03, 0x03},
		{0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e},
		{0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0},
		{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00},
		{0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00},
		{0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0},
		{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78},
		{0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00},
		{0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00},
		{0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00},
		{0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
		{0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f},
		{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
		{0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00}
		};

		for(int j=0;j<13;j++)
		{
			for(int i=0;i<95;i++) this->rasters[i][j]=tmp_rasters[i][j];
		}

		this->char_width=8;
		this->char_height=13;
		this->x_resolution=x_resolution;
		this->y_resolution=y_resolution;
    	GLuint i;
	    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    	fontOffset = glGenLists (128);
	    for (i = 32; i < 127; i++)
     	{
    	    glNewList(i+fontOffset, GL_COMPILE);
        	    glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, rasters[i-32]);
	        glEndList();
    	}
	}

	protected:

	/**
		Affiche le texte donné en paramètre. Cette fonction est utilisée par la
		méthode display. Si length==-1, on affiche la chaine "s" en entier
		( c'est-à-dire justqu'au caractère de fin de chaine '\0' )
	*/
	void printString(const char *s, int length)
	{
    	glPushAttrib (GL_LIST_BIT);
	    glListBase(fontOffset);
    	glCallLists((length==-1)?strlen(s):length, GL_UNSIGNED_BYTE, (GLubyte *) s);
	    glPopAttrib ();
	}

	public:

	/**
		Changement de la résolution d'écran. Il faut faire appel à cette
  		fonction chaque fois que l'écran change de résolution, de manière
  		à ce que les coordonnées du texte soient toujours calculées
  		correctement.
	*/
	void change_resolution(int x_resolution, int y_resolution)
	{
		this->x_resolution=x_resolution;
		this->y_resolution=y_resolution;
	}

	/**
		Afficher dans le canvas opengl la chaîne de caractère s
		à la position x_pos, y_pos avec la couleur color.
		La position est considérée en partant du coin supérieur gauche du
		canvas Opengl. En effet, la fonction opengl glRasterPos2i(x,y) prend
		comme origine le coin inférieur gauche. Mais il semble plus logique,
		dans le cadre de l'affichage de texte en tout cas, de prendre pour
		origine le coin supérieur gauche. C'est pourquoi, dans le cadre de cette
		fonction je procède ainsi : glRasterPos2i(x_pos, y_resolution-y_pos);

		On peut éventuellement spécifier la longueur de la chaine de caractère
		dans le cas ou on ne veux pas afficher "s" en entier. Si length==-1, on
		affiche tout. Cette fonctionnalité est utilisée par la classe TxtWindow
		pour effectuer les retours à la ligne si la chaine est trop longue.
	*/
	void display(const char *s, int x_pos, int y_pos, float color[3]=NULL,int length=-1)
	{
	    int i, j;
	    if(!color)
     	{
      		color=new float[3];
      		color[0]=1.0;
      		color[1]=1.0;
      		color[2]=1.0;
  		}
		glDisable(GL_LIGHTING);
		glColor3fv(color);
		glMatrixMode(GL_PROJECTION);
		glPushMatrix();
	    	glLoadIdentity();
			glMatrixMode(GL_MODELVIEW);
			glPushMatrix();
		    	glLoadIdentity();
    			glOrtho (0.0, x_resolution, 0.0, y_resolution, -1.0, 1.0);

	    		glRasterPos2i(x_pos, y_resolution-y_pos-char_height);

	    		printString(s, length);

 			glPopMatrix();
			glMatrixMode(GL_PROJECTION);
    	glPopMatrix();
	    glMatrixMode(GL_MODELVIEW);

   		//glEnable(GL_LIGHTING);
	}
};

/**
	TxtWindow Défini une fenêtre de texte sur la surface OpenGL.
	Elle permet de gérer l'affichage de texte dans la fenêtre aux "coordonnées
	caractères", sans se soucier de sa position sur l'écran.
	De plus, elle gère le retour à la ligne lorsque le texte est trop grand et
	déborderais de la fenêtre par la droite.
*/
class TxtWindow
{
	public:
	glText2d * text;	//!< Pointeur vers un afficheur de texte
	int interligne;		//!< Nombre de pixel séparant 2 lignes de texte
	int pos_x;			//!< position x de la fenêtre sur l'écran
	int pos_y;			//!< position y de la fenêtre sur l'écran
	int largeur;		//!< largeur de la fenêtre en pixels
	int hauteur;		//!< hauteur de la fenêtre eb pixels

	int nb_lignes;		//!< nombre de lignes de textes affichable
	int longueur_ligne;	//!< nombre de caractères dans une ligne

	/**
		Construit un TxtWindow.
	*/
	TxtWindow(glText2d* _text,int _pos_x,int _pos_y,int _largeur, int _hauteur
			, int _interligne=5)
   				:interligne(_interligne),largeur(_largeur),hauteur(_hauteur)
       			,text(_text),pos_x(_pos_x)
	      		,pos_y(_pos_y)
	{
		nb_lignes=hauteur/(this->text->char_height+interligne);
		longueur_ligne=largeur/(this->text->char_width+2);
	}

	~TxtWindow(){}

	/**
		Cette fonction sert à afficher une chaîne de caractère dans la fenêtre,
		aux coordonnées caractères données en paramètre.
		Elle renvoi la position y (en coordonnée caractères) de la dernière ligne
  		affichée. De manière à ce que l'on puisse afficher le texte suivant
    	directement à la suite.
	*/
	int display(char *s, int x, int y, float color[3]=NULL)
	{
		int longueur_s=strlen(s);

		// Si la chaine de caractère est plus longue qu'une ligne
		// on l'affiche en mettant en place des retours à la ligne.
		if(longueur_s>longueur_ligne)
		{
			char *end_s=(char*)(s+longueur_s);
			int decal_y=0;
			char * ptr=s;

			// Vérifie que l'on a pas atteint le bas de la fenêtre.
			// Si c'est le cas, on n'affiche pas le texte.
			if(y>=nb_lignes) return y;

			text->display(ptr,pos_x+x*(text->char_width+2)
					   ,pos_y+y*(text->char_height+interligne)
    				   ,color,longueur_ligne-x);
				ptr+=(longueur_ligne-x);
				decal_y++;

			// On affiche chaque ligne de texte complète
			while(end_s-ptr>longueur_ligne)
			{
				text->display(ptr,pos_x
					   ,pos_y+(decal_y+y)*(text->char_height+interligne)
    				   ,color,longueur_ligne);

				// Vérifie que l'on n'a pas atteint le bas de la fenêtre.
				// Si c'est le cas, on n'affiche pas la suite du texte.
				if(y+decal_y>=nb_lignes) return y+decal_y;

				ptr+=longueur_ligne;
				decal_y++;
			}

			// Si la longueur de la chaine n'est pas un multiple de la longueur
			// d'une ligne :
			// On affiche la queue de la chaine s
			if(ptr<end_s)
			text->display(ptr,pos_x
					   ,pos_y+(decal_y+y)*(text->char_height+interligne)
    				   ,color,(int)(end_s-ptr));

   			return y+decal_y;
		}
		else	// la chaine tient dans une ligne.
		{
			// Vérifie que l'on a pas atteint le bas de la fenêtre.
			// Si c'est le cas, on n'affiche pas le texte.
			if(y>=nb_lignes) return y;

			text->display(s,pos_x+x*text->char_width
					   ,pos_y+y*(text->char_height+interligne)
    				   ,color);
		}
		return y;
   }

    /**
		Affichage multiligne (découpe la chaine selon les retours chariot.
   */
   int displayMulti(char *s, int x, int y, float color[3]=NULL)
   {
		char *ligne;
		ligne = strtok (s,"\n");
		while (ligne != NULL)
		{
			y = display(ligne,x,y,color)+1;
			ligne = strtok (NULL, "\n");
		}
   }

   /**
		A partir d'une coordonnée y à l'écran, cette fonction en déduit le
		numéro de ligne de texte auquel la ligne écran appartient.
		Cela est particulièrement utile pour les menus, pour déterminé la ligne
		de texte désignée par la souris.
		Si le point n'est pas dans la fenêtre, la fonction retourne -1.
   */
   int numero_ligne(int x,int y)
   {
		if((x>pos_x) && (x<(pos_x+largeur)) && (y>pos_y) && (y<pos_y+hauteur))
		{
			return (y-pos_y)/(text->char_height+interligne);
		}
		return -1;
   }
};

/**
	Cette structure, utilisée par glConsole permet de créer une liste chainée
	circulaire de chaines de caractère. En plus de la chaine elle même, elle
	contient sa couleur.
*/
struct noeud_chaine
{
	float color[3];
	char * chaine;
	noeud_chaine * suivant;
};

/**
	glConsole est une console de texte. Chaque fois qu'on lui envoi une nouvelle
 	chaine avec glConsole::add(char*, float[3]), elle est ajoutée à la suite des
 	autres. Elle gère la liste des lignes de texte sous forme d'une liste
	chainée circulaire. Cela permet de mettre en oeuvre un scrolling du texte
	lorsque la fenêtre est remplie.
*/
class glConsole
{
	public:
	TxtWindow *txtwindow;	//!< Fenêtre d'affichage de la console

	int nb_chaines;			//!< Nombre de chaines de la console
	noeud_chaine * premier; //!< Pointeur sur la première chaine à afficher
	noeud_chaine * dernier;	//!< Pointeur sur le prochain noeud à remplir

	glConsole(glText2d* text,int pos_x,int pos_y,int largeur, int hauteur
			, int interligne=5)
	{
		txtwindow=new TxtWindow(text,pos_x,pos_y,largeur,hauteur,interligne);

		nb_chaines=txtwindow->nb_lignes;

		premier=new noeud_chaine();
		noeud_chaine *ptr=premier;
		for(int i=0;i<nb_chaines-1;i++)
		{
			ptr->chaine=NULL;
			ptr->suivant=new noeud_chaine();
			ptr=ptr->suivant;
		}
		ptr->chaine=NULL;
		ptr->suivant=premier;
		dernier=premier;
	}

	~glConsole()
	{
		noeud_chaine *ptr=premier;
		for(int i=0;i<nb_chaines;i++)
		{
			noeud_chaine *tmp=ptr->suivant;
			delete [] ptr->chaine;
			delete ptr;
			ptr=tmp;
		}

		delete txtwindow;
	}

protected:

	/**
		Cette fonction est utilisée par la fonction add() pour ajouter la chaine
		préalablement découpée, dans la liste. Une length de -1 signifie que
		l'on copie la chaine complète.
	*/
	void add_string(const char *s, float color[3], int length=-1)
	{
		/*
			Si la chain est non nulle dans dernier cela signifie que la console
			est pleine. Donc, on effectue le scrolling : le deuxième deviens
			premier. De cette façon, le premier deviens le dernier et est prèt à
			recevoir le nouveau texte.
		*/
		if(dernier->chaine)
		{
			premier=premier->suivant;
		}

		// on supprime l'ancienne chaine contenue par dernier
		delete [] dernier->chaine;

		// Si la longueur donnée est -1, on prend la chaine complette.
		if(length<0)
		{
  			dernier->chaine=new char[strlen(s)+1];
			strcpy(dernier->chaine,s);
		}
		else
		{
			dernier->chaine=new char[length+1];
			dernier->chaine[length]='\0';
			strncpy(dernier->chaine,s,length);
		}
		// on copie la couleur dans le noeud
		dernier->color[0]=color[0];
		dernier->color[1]=color[1];
		dernier->color[2]=color[2];

		// on positionne dernier sur le prochain noeud à remplir
		dernier=dernier->suivant;
		return;
	}
public:
	/**
		Ajoute une chaîne en bas de la console.
	*/
	void add(const char * s, float color[3])
	{
		int longueur_s=strlen(s);

		// Si la chaîne est trop longue, on la découpe
		if(longueur_s>txtwindow->longueur_ligne)
		{
			const char* ptr=s;	// pointeur de parcour de la chaine "s"
			const char* end_s=(char*)(s+longueur_s);// pointeur sur la fin de la chaine "s"

			// On insère chaque ligne de texte complète
			while(end_s-ptr>txtwindow->longueur_ligne)
			{
				add_string(ptr,color,txtwindow->longueur_ligne);
				ptr=(char*)(ptr+txtwindow->longueur_ligne);
			}
			// On insère le reste de la chaine
			if(ptr<end_s)
			{
				add_string(ptr,color,end_s-ptr);
			}

			return;
		}
		else // sinon, on inscrit la chaine directement.
		{
			add_string(s,color, -1);
			return;
		}
	}

	/**
		Affiche la console. C'est à dire le texte qu'elle contient.
	*/
	void display()
	{
		glDisable(GL_TEXTURE_2D);
		glDisable(GL_DEPTH_TEST);
		int y_courrant=0;
		int rang_courrant=0;
		noeud_chaine *courrant=premier;

		// affichage de chaque ligne de la console
		while(courrant->chaine && (rang_courrant<nb_chaines))
		{
			y_courrant=txtwindow->display(courrant->chaine,0,y_courrant
				,courrant->color)+1;
			courrant=courrant->suivant;
			rang_courrant++;
		}

		glEnable(GL_DEPTH_TEST);
		return;
	}
};

#endif

